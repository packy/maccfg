#!/bin/bash

lift_Cellar () {
    if [[ ! -h $HOME/.homebrew_cellar ]]; then
        ln -sf $(brew --config | grep HOMEBREW_CELLAR | awk '{print $2}') $HOME/.homebrew_cellar
    fi
    readlink $HOME/.homebrew_cellar
}

# so Homebrew compiles git with PCRE
export USE_LIBPCRE=yes

GIT_BIN=$(which git)
HOMEBREW_CELLAR=$(lift_Cellar)
GIT_VERSION=$($GIT_BIN --version | perl -pe 's/git\s+version\s+//;')
GIT_ROOT=$HOMEBREW_CELLAR/git/$GIT_VERSION
GIT_CORE=$GIT_ROOT/libexec/git-core
export PATH=$PATH:$GIT_CORE

export LESS=FRX
alias gb='git branch'
export GITDIR=$HOME/git
alias ggs='cd "$GITDIR"/scriptlib; gp' # go go gadget scriptlib!  ... what?
alias ggm='cd "$GITDIR"/manager_scripts; gp'
alias gge='cd "$GITDIR"/extraclarity; gp'
alias ggg='cd "$GITDIR"/mgmt; gp'
alias ggq='cd "$GITDIR"/qa; gp'
alias ggc='cd "$GITDIR"/compliance; gp'

alias ccolab=/Applications/ccollab_client/ccollab

alias p4noedit='if ! p4 login -s; then p4 login; fi; P4EDITOR=sleep-toucher git p4 submit'
alias p4n='if ! p4 login -s; then p4 login; fi; P4EDITOR=sleep-toucher git p4 submit'

#
# git customizations
#

function git () {
    if [[ $EUID -eq 0 ]]; then
        echo "Don't run git as root!" 1>&2
    else
        /usr/local/bin/git $*
    fi
}

function p4 () {
    if [[ $EUID -eq 0 ]]; then
        echo "Don't run perforce as root!" 1>&2
    else
        /usr/local/bin/p4 $*
    fi
}

function is_git_dir () {
    [ -d .git ] || [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" == "true" ]
}

function is_git_p4_dir () {
    is_git_dir && git cat-file commit HEAD | grep -q git-p4
}

function parse_git_branch {
  WRAP=$1
  ref=$(git-symbolic-ref HEAD 2> /dev/null) || return
  if [[ "$WRAP" = "wrap" ]] ; then
    echo "(${ref#refs/heads/})"
  else
    echo "${ref#refs/heads/}"
  fi
}

function make_git_titlebar {
  case $TERM in
    xterm*)
    TITLEBAR='\[\033]0;\u@\h: \w $(parse_git_branch wrap)\007\]'
    ;;
    *)
    TITLEBAR=""
    ;;
  esac
}

function make_git_prompt () {
  source "$GITDIR"/bash-git-prompt/gitprompt.sh
}
alias gp=make_git_prompt

newbranch () {
    if is_git_dir; then
        git branch $*
        echo Created git branch \"$1\"
        git checkout $1
    else
        echo Not a git dir: $(pwd)
    fi
}

_make_branch_name () {
    perl -e '$str = join "_", @ARGV; if ($ARGV[0] =~ /^\d+$/) { $str = "bug$str"; } print $str;' $*
}

newbug () {
    if is_git_dir; then
        git checkout master
        newbranch $(_make_branch_name $*)
    else
        echo Not a git dir: $(pwd)
    fi
}

mvbug () {
    git branch -m bug$1 bug$2
}

renbug () {
    OLDBRANCH=$(parse_git_branch)
    git branch -m $OLDBRANCH $(_make_branch_name $*)
}

delbug () {
    OLDBRANCH=$(parse_git_branch)
    git co master
    git up
    git branch -d $OLDBRANCH
}

edit_last () {
    xemacs $(perl -e '$foo =`git log -1 --name-only --pretty=oneline`;
                      $foo =~ s/^.*$//m; print $foo;')
}

mergebug () {
    OLDBRANCH=$(parse_git_branch)
    git co master
    git merge $OLDBRANCH
    git branch -d $OLDBRANCH
}

last_sha () {
    git log -1 --pretty='%h'
}

squash_last () {
    git commit --fixup=$(last_sha) $*
}

gl () {
   git log $(local_commits_only)
   printf "\n"
}

gln () {
   git ln $(local_commits_only)
   printf "\n"
}

glb () {
   BUG=parse_git_branch | perl -ne 'chomp; s/bug/bug /; print qq{$_};'
   git log --grep "$BUG"
   printf "\n"
}
glnb () {
   BUG=parse_git_branch | perl -ne 'chomp; s/bug/bug /; print qq{$_};'
   git log --name-only --grep "$BUG"
   printf "\n"
}

syncall () {
   CURDIR=`pwd`
   DIRS=$(find "$GITDIR" -maxdepth 1 -type d | sed -e "s:$GITDIR/::" | grep -v "$GITDIR")
   p4 sync
   for DIR in $DIRS; do
       cd "$GITDIR/$DIR"
       if is_git_p4_dir; then 
           printf "\n\n========================= $DIR =========================\n\n"
           CHANGES=$(git status --short --untracked-files=no)
           OLDBRANCH=$(parse_git_branch)
           if [[ "$CHANGES" != "" ]]; then
               echo Stashing uncommitted changes
               git stash
           fi
           if [[ "$OLDBRANCH" != "master" ]]; then
               git co master
           fi
           git up
           git gc
           if [[ "$OLDBRANCH" != "master" ]]; then
               git co $OLDBRANCH
           fi
           if [[ "$CHANGES" != "" ]]; then
               echo Popping stashed changes
               git stash pop
           fi
       fi
   done
   cd $CURDIR
}

commit_matching ()
{
    MATCHES=$(git status | perl -e '
        $match = shift @ARGV;
        $match = qr/$match/;
        while (<STDIN>) {
            if ( m{$match} ) {
                chomp;
                s/\#\s+modified:\s+/ /;
                print;
            }
        }' $1)
    git commit $MATCHES
}

if [[ -x /Applications/p4merge.app/Contents/Resources/launchp4merge ]]; then
p4diff ()
{
    /Applications/p4merge.app/Contents/Resources/launchp4merge $* &
}
fi

# some perforce stuff, too!
alias p4noedit='P4EDITOR=sleep-toucher git p4 submit'

restore_cursor_clear_down
source_file $GIT_ROOT/etc/bash_completion.d/git-completion.bash
source_file ~/bin/gitp4_auto # experimental
